/**
 * TypeScript code generator for theme colors.
 */
import * as fs from 'fs';
import * as path from 'path';
import { CONFIG } from './config';
import {
  getExtensionFilename,
  getExtensionTsPath,
  getExtensionMetaPath,
} from './scanner';
import type { ExtractedTheme, ExtensionMetadata, ThemeColors } from './types';

/**
 * Formats a ThemeColors object as TypeScript code.
 */
function formatColors(colors: ThemeColors): string {
  const parts: string[] = [`'editor.background': '${colors['editor.background']}'`];

  // Add optional color keys in a consistent order
  const optionalKeys = [
    'editor.foreground',
    'titleBar.activeBackground',
    'titleBar.activeForeground',
    'titleBar.inactiveBackground',
    'titleBar.inactiveForeground',
    'statusBar.background',
    'statusBar.foreground',
    'activityBar.background',
    'activityBar.foreground',
  ] as const;

  for (const key of optionalKeys) {
    if (colors[key]) {
      parts.push(`'${key}': '${colors[key]}'`);
    }
  }

  if (parts.length === 1) {
    return `{ ${parts[0]} }`;
  }

  return `{\n      ${parts.join(',\n      ')},\n    }`;
}

/**
 * Formats a theme name for use as an object key.
 * Uses JSON.stringify to handle all edge cases (numeric strings, special
 * characters, embedded quotes, unicode).
 */
function formatThemeName(name: string): string {
  return JSON.stringify(name);
}

interface ThemeConflict {
  kept: ExtractedTheme;
  discarded: ExtractedTheme;
}

interface MergeResult {
  themes: Map<string, ExtractedTheme>;
  conflicts: ThemeConflict[];
}

/**
 * Merges new themes with existing themes, resolving conflicts by keeping
 * the theme from the extension with more downloads.
 */
function mergeThemes(
  newThemes: ExtractedTheme[],
  existingThemes?: Map<string, ExtractedTheme>
): MergeResult {
  const mergedThemes = new Map<string, ExtractedTheme>();
  const conflicts: ThemeConflict[] = [];

  if (existingThemes) {
    for (const [name, theme] of existingThemes) {
      mergedThemes.set(name, theme);
    }
  }

  for (const theme of newThemes) {
    const existing = mergedThemes.get(theme.name);

    if (existing && existing.extensionId !== theme.extensionId) {
      // Conflict: same name from different extensions
      if (theme.installCount > existing.installCount) {
        mergedThemes.set(theme.name, theme);
        conflicts.push({ kept: theme, discarded: existing });
      } else {
        conflicts.push({ kept: existing, discarded: theme });
      }
    } else {
      mergedThemes.set(theme.name, theme);
    }
  }

  return { themes: mergedThemes, conflicts };
}

/**
 * Generates TypeScript code for the GENERATED_THEME_COLORS constant.
 */
export function generateTypeScriptCode(
  themes: ExtractedTheme[],
  existingThemes?: Map<string, ExtractedTheme>
): string {
  const { themes: mergedThemes, conflicts } = mergeThemes(
    themes,
    existingThemes
  );

  // Log warnings for conflicts
  if (conflicts.length > 0) {
    console.warn('');
    console.warn(`Found ${conflicts.length} duplicate theme name(s):`);
    for (const { kept, discarded } of conflicts) {
      console.warn(
        `  "${kept.name}": keeping from "${kept.extensionName}" ` +
          `(${kept.installCount.toLocaleString()} installs), ` +
          `discarding from "${discarded.extensionName}" ` +
          `(${discarded.installCount.toLocaleString()} installs)`
      );
    }
    console.warn('');
  }

  // Sort alphabetically for stable diffs
  const sortedNames = Array.from(mergedThemes.keys()).sort((a, b) =>
    a.localeCompare(b, undefined, { sensitivity: 'base' })
  );

  const timestamp = new Date().toISOString();
  const lines: string[] = [
    '/**',
    ' * Auto-generated theme colors.',
    ` * Generated: ${timestamp}`,
    ' *',
    ' * This file is auto-generated by scripts/extract-theme-colors.',
    ' * Do not edit manually - changes will be overwritten.',
    ' *',
    ' * To add custom themes, use the patina.theme.colors setting.',
    ' */',
    '',
    "import type { ThemeInfo } from './colors';",
    '',
    'export const GENERATED_THEME_COLORS: Record<string, ThemeInfo> = {',
  ];

  for (const name of sortedNames) {
    const theme = mergedThemes.get(name)!;
    const formattedName = formatThemeName(name);
    const colors = formatColors(theme.colors);

    lines.push(`  ${formattedName}: {`);
    lines.push(`    colors: ${colors},`);
    lines.push(`    type: '${theme.type}',`);
    lines.push('  },');
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Writes the generated TypeScript code to a file.
 */
export function writeOutputFile(outputPath: string, content: string): void {
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(outputPath, content);
}

/**
 * Generates a summary report of extracted themes.
 */
export function generateReport(themes: ExtractedTheme[]): string {
  const darkThemes = themes.filter(
    (t) => t.type === 'dark' || t.type === 'hcDark'
  );
  const lightThemes = themes.filter(
    (t) => t.type === 'light' || t.type === 'hcLight'
  );

  const lines: string[] = [
    '# Theme Extraction Report',
    '',
    `Total themes extracted: ${themes.length}`,
    `  - Dark themes: ${darkThemes.length}`,
    `  - Light themes: ${lightThemes.length}`,
    '',
    '## Themes with per-element colors',
    '',
  ];

  const themesWithElements = themes.filter(
    (t) =>
      t.colors['titleBar.activeBackground'] ||
      t.colors['statusBar.background'] ||
      t.colors['activityBar.background']
  );

  if (themesWithElements.length === 0) {
    lines.push('No themes with per-element colors found.');
  } else {
    for (const theme of themesWithElements) {
      const elements: string[] = [];
      if (theme.colors['titleBar.activeBackground']) {
        elements.push('titleBar');
      }
      if (theme.colors['statusBar.background']) {
        elements.push('statusBar');
      }
      if (theme.colors['activityBar.background']) {
        elements.push('activityBar');
      }
      lines.push(`- ${theme.name}: ${elements.join(', ')}`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

/**
 * Generates TypeScript code for a single extension's themes.
 */
export function generateExtensionFileCode(themes: ExtractedTheme[]): string {
  // Sort alphabetically by name for stable diffs
  const sortedThemes = [...themes].sort((a, b) =>
    a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
  );

  const lines: string[] = [
    "import type { ThemeInfo } from '../../colors';",
    '',
    'export const THEMES: Record<string, ThemeInfo> = {',
  ];

  for (const theme of sortedThemes) {
    const formattedName = formatThemeName(theme.name);
    const colors = formatColors(theme.colors);

    lines.push(`  ${formattedName}: {`);
    lines.push(`    colors: ${colors},`);
    lines.push(`    type: '${theme.type}',`);
    lines.push('  },');
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Writes an extension's theme file and metadata.
 */
export function writeExtensionFile(
  publisherName: string,
  extensionName: string,
  themes: ExtractedTheme[],
  metadata: ExtensionMetadata
): void {
  // Ensure directory exists
  if (!fs.existsSync(CONFIG.extensionsDir)) {
    fs.mkdirSync(CONFIG.extensionsDir, { recursive: true });
  }

  // Write .ts file
  const tsPath = getExtensionTsPath(publisherName, extensionName);
  const tsContent = generateExtensionFileCode(themes);
  fs.writeFileSync(tsPath, tsContent);

  // Write .meta.json file
  const metaPath = getExtensionMetaPath(publisherName, extensionName);
  fs.writeFileSync(metaPath, JSON.stringify(metadata, null, 2) + '\n');
}

/**
 * Deletes an extension's theme file and metadata.
 */
export function deleteExtensionFile(
  publisherName: string,
  extensionName: string
): void {
  const tsPath = getExtensionTsPath(publisherName, extensionName);
  const metaPath = getExtensionMetaPath(publisherName, extensionName);

  if (fs.existsSync(tsPath)) {
    fs.unlinkSync(tsPath);
  }
  if (fs.existsSync(metaPath)) {
    fs.unlinkSync(metaPath);
  }
}

/**
 * Information needed to generate the index file.
 */
export interface ExtensionFileInfo {
  publisherName: string;
  extensionName: string;
  installCount: number;
  themes: ExtractedTheme[];
}

/**
 * Strips the timestamp line from generated content for comparison.
 */
function stripTimestamp(content: string): string {
  return content.replace(/^ \* Generated: .+$/m, '');
}

/**
 * Generates the aggregated index.ts file that exports all themes.
 */
export function generateIndexCode(
  extensionInfos: ExtensionFileInfo[],
  timestamp?: string
): string {
  // Build a map from extension key to info for conflict resolution
  const extensionMap = new Map<string, ExtensionFileInfo>();
  for (const info of extensionInfos) {
    const key = `${info.publisherName}.${info.extensionName}`;
    extensionMap.set(key, info);
  }

  // Collect all themes, resolving conflicts by install count
  const themeMap = new Map<string, { theme: ExtractedTheme; extKey: string }>();
  const conflicts: ThemeConflict[] = [];

  for (const info of extensionInfos) {
    const extKey = `${info.publisherName}.${info.extensionName}`;
    for (const theme of info.themes) {
      const existing = themeMap.get(theme.name);
      if (existing && existing.extKey !== extKey) {
        // Conflict: same name from different extensions
        if (theme.installCount > existing.theme.installCount) {
          themeMap.set(theme.name, { theme, extKey });
          conflicts.push({ kept: theme, discarded: existing.theme });
        } else {
          conflicts.push({ kept: existing.theme, discarded: theme });
        }
      } else {
        themeMap.set(theme.name, { theme, extKey });
      }
    }
  }

  // Log conflicts
  if (conflicts.length > 0) {
    console.warn('');
    console.warn(`Found ${conflicts.length} duplicate theme name(s):`);
    for (const { kept, discarded } of conflicts) {
      console.warn(
        `  "${kept.name}": keeping from "${kept.extensionName}" ` +
          `(${kept.installCount.toLocaleString()} installs), ` +
          `discarding from "${discarded.extensionName}" ` +
          `(${discarded.installCount.toLocaleString()} installs)`
      );
    }
    console.warn('');
  }

  // Collect unique extension keys that have themes included
  const includedExtKeys = new Set<string>();
  for (const [, { extKey }] of themeMap) {
    includedExtKeys.add(extKey);
  }

  // Get extension infos for included extensions
  const includedExtensions: ExtensionFileInfo[] = [];
  for (const extKey of includedExtKeys) {
    const info = extensionMap.get(extKey);
    if (info) {
      includedExtensions.push(info);
    }
  }

  // Sort by filename for stable output
  includedExtensions.sort((a, b) => {
    const aFile = getExtensionFilename(a.publisherName, a.extensionName);
    const bFile = getExtensionFilename(b.publisherName, b.extensionName);
    return aFile.localeCompare(bFile);
  });

  const ts = timestamp ?? new Date().toISOString();
  const lines: string[] = [
    '/**',
    ' * Auto-generated aggregated theme colors.',
    ` * Generated: ${ts}`,
    ' *',
    ' * This file is auto-generated by scripts/extract-theme-colors.',
    ' * Do not edit manually - changes will be overwritten.',
    ' */',
    '',
    "import type { ThemeInfo } from '../colors';",
    '',
  ];

  // Generate imports
  for (const info of includedExtensions) {
    const filename = getExtensionFilename(info.publisherName, info.extensionName);
    // Create a safe variable name from the filename
    // Prefix with underscore if it starts with a number
    let varName = filename.replace(/[.-]/g, '_');
    if (/^\d/.test(varName)) {
      varName = '_' + varName;
    }
    lines.push(
      `import { THEMES as ${varName} } from './extensions/${filename}';`
    );
  }

  lines.push('');
  lines.push('export const GENERATED_THEME_COLORS: Record<string, ThemeInfo> = {');

  // Spread imports in order
  for (const info of includedExtensions) {
    const filename = getExtensionFilename(info.publisherName, info.extensionName);
    let varName = filename.replace(/[.-]/g, '_');
    if (/^\d/.test(varName)) {
      varName = '_' + varName;
    }
    lines.push(`  ...${varName},`);
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

/**
 * Writes the aggregated index.ts file if content has changed.
 * Returns true if the file was written, false if skipped (no changes).
 */
export function writeIndexFile(extensionInfos: ExtensionFileInfo[]): boolean {
  // Ensure directory exists
  if (!fs.existsSync(CONFIG.outputDir)) {
    fs.mkdirSync(CONFIG.outputDir, { recursive: true });
  }

  const newContent = generateIndexCode(extensionInfos);

  // Check if existing file has the same content (ignoring timestamp)
  if (fs.existsSync(CONFIG.indexPath)) {
    const existingContent = fs.readFileSync(CONFIG.indexPath, 'utf-8');
    if (stripTimestamp(existingContent) === stripTimestamp(newContent)) {
      return false;
    }
  }

  fs.writeFileSync(CONFIG.indexPath, newContent);
  return true;
}
