import * as assert from 'assert';
import * as vscode from 'vscode';
import {
  clearGitRepoRootCache,
  resolveGitRepoRoot,
  type WorkspaceFs,
} from '../../workspace/gitRoot';

interface MockEntry {
  readonly type: 'file' | 'directory';
  readonly content?: string;
}

interface MockFsOptions {
  readonly statErrors?: readonly vscode.Uri[];
  readonly readErrors?: readonly vscode.Uri[];
}

class MockFs implements WorkspaceFs {
  public statCalls = 0;
  public readCalls = 0;

  private readonly entries = new Map<string, MockEntry>();
  private readonly statErrorKeys = new Set<string>();
  private readonly readErrorKeys = new Set<string>();

  private readonly encoder = new TextEncoder();

  constructor(
    entries: readonly [vscode.Uri, MockEntry][],
    options: MockFsOptions = {}
  ) {
    for (const [uri, entry] of entries) {
      this.entries.set(uri.toString(), entry);
    }

    for (const uri of options.statErrors ?? []) {
      this.statErrorKeys.add(uri.toString());
    }

    for (const uri of options.readErrors ?? []) {
      this.readErrorKeys.add(uri.toString());
    }
  }

  public async stat(uri: vscode.Uri): Promise<vscode.FileStat> {
    this.statCalls += 1;

    const key = uri.toString();
    if (this.statErrorKeys.has(key)) {
      throw new Error('stat failed');
    }

    const entry = this.entries.get(key);
    if (!entry) {
      throw vscode.FileSystemError.FileNotFound(uri);
    }

    return {
      type:
        entry.type === 'directory'
          ? vscode.FileType.Directory
          : vscode.FileType.File,
      ctime: 0,
      mtime: 0,
      size: entry.content?.length ?? 0,
    };
  }

  public async readFile(uri: vscode.Uri): Promise<Uint8Array> {
    this.readCalls += 1;

    const key = uri.toString();
    if (this.readErrorKeys.has(key)) {
      throw new Error('read failed');
    }

    const entry = this.entries.get(key);
    if (!entry || entry.type !== 'file') {
      throw vscode.FileSystemError.FileNotFound(uri);
    }

    return this.encoder.encode(entry.content ?? '');
  }
}

suite('resolveGitRepoRoot', () => {
  setup(() => {
    clearGitRepoRootCache();
  });

  test('resolves repository root from .git directory', async () => {
    const folder = vscode.Uri.file('/repo/packages/app');
    const gitDir = vscode.Uri.file('/repo/.git');

    const fs = new MockFs([[gitDir, { type: 'directory' }]]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.path, '/repo');
  });

  test('resolves canonical root from linked worktree + commondir', async () => {
    const folder = vscode.Uri.file('/worktrees/feature');
    const gitMarker = vscode.Uri.file('/worktrees/feature/.git');
    const commonDirFile = vscode.Uri.file(
      '/repos/app/.git/worktrees/feature/commondir'
    );

    const fs = new MockFs([
      [
        gitMarker,
        {
          type: 'file',
          content: 'gitdir: /repos/app/.git/worktrees/feature\n',
        },
      ],
      [commonDirFile, { type: 'file', content: '../..\n' }],
    ]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.path, '/repos/app');
  });

  test('supports relative gitdir pointer paths', async () => {
    const folder = vscode.Uri.file('/tmp/worktrees/feature');
    const gitMarker = vscode.Uri.file('/tmp/worktrees/feature/.git');
    const commonDirFile = vscode.Uri.file(
      '/tmp/repos/app/.git/worktrees/feature/commondir'
    );

    const fs = new MockFs([
      [
        gitMarker,
        {
          type: 'file',
          content: 'gitdir: ../../repos/app/.git/worktrees/feature\n',
        },
      ],
      [commonDirFile, { type: 'file', content: '../..\n' }],
    ]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.path, '/tmp/repos/app');
  });

  test('returns undefined for malformed .git pointer files', async () => {
    const folder = vscode.Uri.file('/repo');
    const gitMarker = vscode.Uri.file('/repo/.git');

    const fs = new MockFs([
      [gitMarker, { type: 'file', content: 'not a gitdir pointer\n' }],
    ]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.strictEqual(result, undefined);
  });

  test('ignores non-matching lines before gitdir pointer', async () => {
    const folder = vscode.Uri.file('/worktrees/feature');
    const gitMarker = vscode.Uri.file('/worktrees/feature/.git');

    const fs = new MockFs([
      [
        gitMarker,
        {
          type: 'file',
          content:
            '# generated by tool\nmetadata: true\ngitdir: /repos/app/.git/worktrees/feature\n',
        },
      ],
    ]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.path, '/repos/app');
  });

  test('walks up parent directories to find .git marker', async () => {
    const folder = vscode.Uri.file('/repo/packages/frontend/src');
    const gitDir = vscode.Uri.file('/repo/.git');

    const fs = new MockFs([[gitDir, { type: 'directory' }]]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.path, '/repo');
  });

  test('supports remote URIs', async () => {
    const folder = vscode.Uri.from({
      scheme: 'vscode-remote',
      authority: 'ssh-remote+myhost',
      path: '/home/user/worktrees/feature',
    });

    const gitMarker = vscode.Uri.from({
      scheme: 'vscode-remote',
      authority: 'ssh-remote+myhost',
      path: '/home/user/worktrees/feature/.git',
    });

    const commonDirFile = vscode.Uri.from({
      scheme: 'vscode-remote',
      authority: 'ssh-remote+myhost',
      path: '/home/user/repos/app/.git/worktrees/feature/commondir',
    });

    const fs = new MockFs([
      [
        gitMarker,
        {
          type: 'file',
          content: 'gitdir: /home/user/repos/app/.git/worktrees/feature\n',
        },
      ],
      [commonDirFile, { type: 'file', content: '../..\n' }],
    ]);

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.ok(result);
    assert.strictEqual(result?.scheme, 'vscode-remote');
    assert.strictEqual(result?.authority, 'ssh-remote+myhost');
    assert.strictEqual(result?.path, '/home/user/repos/app');
  });

  test('returns undefined when stat throws non-FileNotFound errors', async () => {
    const folder = vscode.Uri.file('/repo');
    const gitMarker = vscode.Uri.file('/repo/.git');

    const fs = new MockFs([], {
      statErrors: [gitMarker],
    });

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.strictEqual(result, undefined);
  });

  test('returns undefined when .git file cannot be read', async () => {
    const folder = vscode.Uri.file('/repo');
    const gitMarker = vscode.Uri.file('/repo/.git');

    const fs = new MockFs(
      [[gitMarker, { type: 'file', content: 'gitdir: /repo/.git\n' }]],
      { readErrors: [gitMarker] }
    );

    const result = await resolveGitRepoRoot(folder, {
      fs,
      cache: new Map(),
    });

    assert.strictEqual(result, undefined);
  });

  test('does not persist unresolved lookups in cache', async () => {
    const folder = vscode.Uri.file('/repo');
    const fs = new MockFs([]);
    const cache = new Map<string, Promise<vscode.Uri | undefined>>();

    const first = await resolveGitRepoRoot(folder, { fs, cache });
    const callsAfterFirst = fs.statCalls;
    const second = await resolveGitRepoRoot(folder, { fs, cache });

    assert.strictEqual(first, undefined);
    assert.strictEqual(second, undefined);
    assert.ok(fs.statCalls > callsAfterFirst);
  });

  test('memoizes successful lookups by URI', async () => {
    const folder = vscode.Uri.file('/repo');
    const gitDir = vscode.Uri.file('/repo/.git');

    const fs = new MockFs([[gitDir, { type: 'directory' }]]);
    const cache = new Map<string, Promise<vscode.Uri | undefined>>();

    const first = await resolveGitRepoRoot(folder, { fs, cache });
    const second = await resolveGitRepoRoot(folder, { fs, cache });

    assert.ok(first);
    assert.ok(second);
    assert.strictEqual(first?.path, '/repo');
    assert.strictEqual(second?.path, '/repo');
    assert.strictEqual(fs.statCalls, 1);
  });

  test('clearGitRepoRootCache evicts default cache entries', async () => {
    const folder = vscode.Uri.file('/repo-clear');
    const gitDir = vscode.Uri.file('/repo-clear/.git');

    const fs = new MockFs([[gitDir, { type: 'directory' }]]);

    const first = await resolveGitRepoRoot(folder, { fs });
    const second = await resolveGitRepoRoot(folder, { fs });
    clearGitRepoRootCache();
    const third = await resolveGitRepoRoot(folder, { fs });

    assert.ok(first);
    assert.ok(second);
    assert.ok(third);
    assert.strictEqual(first?.path, '/repo-clear');
    assert.strictEqual(second?.path, '/repo-clear');
    assert.strictEqual(third?.path, '/repo-clear');
    assert.strictEqual(fs.statCalls, 2);
  });
});
